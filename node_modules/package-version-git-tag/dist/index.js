"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const git_1 = require("./git");
const utils_1 = require("./utils");
async function getVersionTagData() {
    const projectPkgPath = path.join(process.cwd(), 'package.json');
    const projectPkgData = await utils_1.readJSONFile(projectPkgPath);
    if (utils_1.isPkgData(projectPkgData)) {
        const { version } = projectPkgData;
        /**
         * @see https://github.com/sindresorhus/np/blob/v5.1.3/source/util.js#L51-L65
         * @see https://github.com/npm/cli/blob/v6.13.0/lib/version.js#L311
         * @see https://github.com/yarnpkg/yarn/blob/v1.19.1/src/cli/commands/version.js#L194
         */
        const prefix = await utils_1.getConfig({
            npm: 'tag-version-prefix',
            yarn: 'version-tag-prefix',
        });
        /**
         * @see https://github.com/npm/cli/blob/v6.13.0/lib/version.js#L311
         * @see https://github.com/yarnpkg/yarn/blob/v1.19.1/src/cli/commands/version.js#L206
         */
        const tagName = `${prefix}${version}`;
        /**
         * @see https://github.com/npm/cli/blob/v6.13.0/lib/version.js#L296
         * @see https://github.com/yarnpkg/yarn/blob/v1.19.1/src/cli/commands/version.js#L191
         */
        const message = (await utils_1.getConfig({ npm: 'message', yarn: 'version-git-message' })).replace(/%s/g, version);
        return { tagName, message };
    }
    throw new Error('Failed to find version tag name.');
}
async function gitTagAlreadyExists(versionTagName, tagMessage, opts) {
    if (!(await git_1.isHeadTag(versionTagName))) {
        throw new Error(`Git tag '${versionTagName}' already exists`);
    }
    if (opts.verbose) {
        await git_1.setTag(versionTagName, {
            message: tagMessage,
            debug: (commandText) => `> #${commandText}\n  # tag '${versionTagName}' already exists`,
            dryRun: true,
        });
    }
}
async function main(opts) {
    if (opts.dryRun) {
        console.error('Dry Run enabled');
        opts.verbose = true;
    }
    const { tagName: versionTagName, message } = await getVersionTagData();
    if (await git_1.tagExists(versionTagName)) {
        await gitTagAlreadyExists(versionTagName, message, opts);
    }
    else {
        await git_1.setTag(versionTagName, {
            message,
            debug: opts.verbose,
            dryRun: opts.dryRun,
        });
    }
    if (opts.push) {
        await git_1.push(versionTagName, {
            debug: opts.verbose,
            dryRun: opts.dryRun,
        });
    }
}
async function default_1(opts = {}) {
    try {
        await main(opts);
    }
    finally {
        utils_1.endPrintVerbose();
    }
}
exports.default = default_1;
//# sourceMappingURL=index.js.map